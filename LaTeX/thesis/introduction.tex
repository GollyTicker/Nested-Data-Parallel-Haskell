

Suppose one wants use the exponentially
increasing number of processors and machines
available to speed-up programs.
This is a common task in image processing.
Data parallelism is a frequently used
to parallelize these programs.

Data-parallel programs express parallelism
via bulkd-primitives over parallel data structures - e.g. \c{map/reduce}.
They perform well on flat data and with regular
non-recursive program flow.
Most applications in need of parallelism
however have irregular behaviour. Their
algorithms work with nested
arrays (e.g. images or matrices),
graphs, trees or complex recursion (e.g. clustering or machine learning).
Direct parallel implementation of such algorithms
in flat data parallelism results in
a performance penalty.

Nested Data Parallelism \cite{Belloch1996} lifts these limits
and enables the high-level expression of irregularly-parallel programs
- while still compiling to efficient machine code.
It uses a non-trivial program transformation called 'Vectorization'
(or 'Flattening') where the original program is transformed
into an equivalent flat data-parallel program.

Due properties like Immutability and Referential Transparency,
Functional programming languages are fruitful grounds for
sophisticated program transformations
and high-level expressiveness. They are key building
blocks for Nested Data Parallelism.

\paragraph{}
This thesis is about the effectiveness of Nested Data Parallelism
in functional programming languages like Haskell for the
expression of irregular image processing algorithms.


\section{Aim and Methodology}
  The question on how Nested Data Parallelism (NDP) compares to
  conventional parallelism is tackled by the following methodology:
  An image processing algorithm with irregular behaviour
  is implemented in four variations. These variations are
  then compared on performance, human workload and other aspects.
  Finally a conclusion is drawn.
  
  \paragraph{}
    \ac $:=$ \algo, a conceptual image processing algorithm
    
    \seq $:=$ A direct sequential implementation of \ac

    \man $:=$ A manually-parallelized implementation of \ac
    
    \ndpn $:=$ A nested data-parallel implementation of \ac

    \ndpv $:=$ The vectorized implementation of \ac from \ndpn
  
  
  Given the generalisations of NDP into Haskell \cite{Harness2008},
  Haskell is an optimal choice for the implementation.
  The results of this thesis however can be easily adopted
  to related functional programming languages.
  
  Contrary to any expectations,
  the thesis does not present directly executable
  programs. NDP is Haskell is still in developement and
  the program transformation is not yet completely implemented.
  The vectorization - usually done by the compiler
  - is done manually here.
  This leads to a theoretical analysis of all programs
  instead of benchmarking and statistical analysis.
  
  The image processing algorithm used
  for \ac is \algo.
  After consideration of alternatives, \algo
  is irregular as well as simple enough
  to be implemented three times and manually vectorized.

\section{Structure}
  This thesis begins with the basics in chapter \ref{chapter:basics}. It
  presents Haskell, Nested Data Parallelism and Vectorization,
  parallel complexity measures and gives a description of \algo.
  The subsequent four chapters
  present and analyse four implementations.
  First, the sequential \seq
  is presented (chapter \ref{chapter:seq}).
  Second, comes the manually parallelized \man
  (chapter \ref{chapter:man}).
  Third, the nested data parallel \ndpn
  is given (chapter \ref{chapter:ndpn}).
  Fourth, its vectorization \ndpn is examined
  (chapter \ref{chapter:ndpv}).
  The thesis then evaluates and compares the programs
  in chapter \ref{chapter:results}.
  Finally, chapter \ref{chapter:outlook}
  summarizes the thesis, states related work and gives an outlook.
  
  %TODO: citations
  

