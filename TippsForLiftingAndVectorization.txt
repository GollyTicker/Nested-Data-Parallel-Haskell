
Naming conventions.

mapP
  is the parallel array variant of map.
  it operates on user-arrays [: a :]

lengthPA
  is the parallel array variant of lengthP which
  operates on the type-dependent representation

mapPV is the vectorized mapP function

mapPS is the concrete scalar version in mapPV
mapPL is the concrete lifted version in mapPV

Let expresion vectorization:
V[ let a = b in c ] = (\a -> V[c]) V[b]
  Proof see #11

Let expression lifting:
L[ let a = b in c ] n
L[ (\a -> c) b ] n
  = L[\a -> c] $:L L[b]
  = AClo {
       aenv = ATupk n y1..yk
      ,ascalar = \(y1..yk) a -> V[c]
      ,alifted = \(ATupk n y1..yk) a -> L[c] n
    } $:L L[b] n
  = (\a -> (L[c] n)) (L[b] n)

Vectorization of an applied lambda:
V[ (\a -> c) b] = (\a -> V[c]) $: V[b]

V[ f ] = V[ \a -> b ] where f is declared top-level
V[ f ] =
  Clo {
     env = ()
    ,scalar = \() a -> V[b]
    ,lifted = \(ATup0 n) a -> L[b] n
  }

Innerhalb eines mapP wird die scalare Variante nicht mehr benÃ¶tigt.
mapP f xs wird immer fL verwenden (siehe Core of flattening). 


Optimization steps in GHC: http://stackoverflow.com/questions/12653787/what-optimizations-can-ghc-be-expected-to-perform-reliably/12661937#12661937

* Strictness Alanysis / Immediate calculation
* Common Subexpression elimination
* Inlining
* Merged case expressions
* Communication Fusioning / Stream Fusioning

DESUGARING -> VECTORIZATION -> FUSION -> GANG PARALLELISM

Example Definition: (extracted from DPH Status report)
sumPS = sumD . mapD sumS . splitD


"For an explanation of the used closure conversion: See Higher Order Flattening, p.43, 4.3.2, p.57 in PDF"

"Core of flattening - Vectorized mapP: [Harness2008 Page 20-21]"

"See Higher Order Flattening, p.55, 4.5, p.69 in PDF"

-- Definition of mapPV (from lifted combinators and DPH - Status Report)
mapPV   :: (a :-> b) :-> PA a :-> PA b
mapPV   = Clo () mapP1 mapP2

mapP1 :: () -> (a :-> b) -> PA a :-> PA b
mapP1 _ fv = Clo fv mapPS mapPL

mapP2 :: PA () -> PA (a :-> b) -> PA (PA a :-> PA b)
mapP2 _ fvs = AClo fvs mapPS mapPL

mapPS :: (a :-> b) -> PA a -> PA b
mapPS fv as
  = replPA (lengthPA as) fv $:^ as -- whcih simplifies. (proof see #10)
  = fv (replPA (lengthPA as) env) as

mapPL :: PA (a :-> b) -> PA (PA a) -> PA (PA b)
mapPL
  = \fv ass -> unconcatPA ass $ replsPA (getSegd ass) fv $:L concatPA ass
  = \(AClo aenv _ fl) ass -> unconcatPA ass . fl (replsPA (getSegd ass) aenv) . concatPA $ ass -- simplified #12

"Why scalar and lifted variant in (Array) Closures?"

Closure ---> replP, mapP ---> Array Closure
  ^                               |
  |                               | 
  +----------   indexP    <-------+

In code appliations need to be able to switch inbetween
both varients to account for repliations, mapping and indexing in context.

#10: 

mapPS :: (a :-> b) - PA a -> PA b
  = \fv as -> replPa (lengthPA as) fv $:L as
  = \fv@(Clo env fs fl) as -> replPa (lengthPA as) fv $:L as
-- Definition of replPA for Closures
  = AClo (replPA (lengthPA as) env) fs fv $:L as
-- Definition of $:L
  = fv (replPA (lengthPA as) env) as

#12:

mapPL
  = \fv ass -> unconcatPA ass $ replsPA (getSegd ass) fv $:L concatPA ass
  = \fv@(AClo aenv fs fl) ass -> unconcatPA ass $ replsPA (getSegd ass) fv $:L concatPA ass
-- Definition of replsPA for PA (a :-> b)         See "Lifted.Closure" https://hackage.haskell.org/package/dph-lifted-vseg-0.7.0.1/docs/src/Data-Array-Parallel-Lifted-Closure.html#%3A-%3E
  = \(AClo aenv fs fl) ass -> unconcatPA ass $ AClo (replsPA (getSegd ass) aenv) fs fl) $:L concatPA ass
-- Definition of $:L
  = \(AClo aenv fs fl) ass -> unconcatPA ass . fl (replsPA (getSegd ass) aenv) . concatPA $ ass



" Lifted.Combinators: https://hackage.haskell.org/package/dph-lifted-vseg-0.7.0.1/docs/src/Data-Array-Parallel-Lifted-Combinators.html#emptyPP"



                      REWRITE RULES

"unitEnv" forall body xs.
            (\(ATup0 n) xs' -> body )
              (replPA (lengthPA xs) ())
              xs
            = (\n xs' -> body ) (lengthPA xs) xs


-- TODO: get all rewrite rules from Higher Order flattening!
    needed?

-- TOOD: get all rewrite rules from all files in the libraries
    grep -rl "RULE" . | xargs -L1 gedit
    http://askubuntu.com/questions/55325/how-to-use-grep-command-to-find-text-including-subdirectories
    http://stackoverflow.com/questions/2711001/how-to-apply-shell-command-to-each-line-of-a-command-output
    grep -r -A 7 "\-# RULE" .

"unitEnv" proof
f :: PA () -> PA a -> PA a
f (replPA (lengthPA xs) ()) xs
  -- definition of lifted
  = (\(ATup0 n) xs -> body )
    (replPA (lengthPA xs) ())
    xs
  -- no need of Unit Environment-Variables
  = (\n xs -> body ) (lengthPA xs) xs



"Efficient Type dependent functions over Arrays"
class PR a where
  -- O(1)
  indexPA       :: PA a -> Int -> a
  lengthPA      :: PA a -> Int
  
  -- O(n)
  emptyPA       :: PA a
  replicatePA   :: Int -> a -> PA a
  
  -- =(sum lengths)
  replicatesPA  :: Segd -> PA a -> PA a
    
  -- O(slice len)
  extractPA,slicePA  :: PA a -> Int -> Int -> PA a
  
  -- > O(n)
  appendPA      :: PA a -> PA a -> PA a
  combine2PA    :: Sel2 -> PA a -> PA a -> PA a
  
  -- ?
  appendvsPA    :: U.Segd
                -> U.VSegd -> PAs a
                -> U.VSegd -> PAs a
                -> PA a
  indexsPA      :: PA (PA a) -> PA (Int, Int) -> PA a
  indexvsPA     :: PAs a -> U.VSegd -> U.Array (Int, Int) -> PA a
  extractssPA    :: PAs a -> U.SSegd -> PA a
  extractvsPA    :: PAs a -> U.VSegd -> PA a














