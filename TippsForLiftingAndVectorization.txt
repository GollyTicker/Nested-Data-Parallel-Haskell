
Naming conventions.

mapP
  is the parallel array variant of map.
  it operates on user-arrays [: a :]

lengthPA
  is the parallel array variant of lengthP which
  operates on the type-dependent representation

mapPV is the vectorized mapP function

mapPS is the concrete scalar version in mapPV
mapPL is the concrete lifted version in mapPV

Let expresion vectorization:
V[ let a = b in c ] = (\a -> V[c]) V[b]
  Proof see #11

Let expression lifting:
L[ let a = b in c ] n
L[ (\a -> c) b ] n
  = L[\a -> c] $:L L[b]
  = AClo {
       aenv = ATupk n y1..yk
      ,ascalar = \(y1..yk) a -> V[c]
      ,alifted = \(ATupk n y1..yk) a -> L[c] n
    } $:L L[b] n
  = (\a -> (L[c] n)) (L[b] n)

Vectorization of an applied lambda:
V[ (\a -> c) b] = (\a -> V[c]) $: V[b]

V[ f ] = V[ \a -> b ] where f is declared top-level
V[ f ] =
  Clo {
     env = ()
    ,scalar = \() a -> V[b]
    ,lifted = \(ATup0 n) a -> L[b] n
  }

Innerhalb eines mapP wird ide scalare Variante nicht mehr benÃ¶tigt.
mapP f xs wird immer fL verwenden (siehe Core of flattening). 


Core of flattening - Vectorized mapP: [Harness2008 Page 20-21]

mapPV :: (a :-> b) :-> PA a :-> PA b
mapPV = Clo
          ()
          (\() f -> Clo f mapPS mapPL)
          (\() fs -> AClo fs mapPS mapPL)

mapPS :: (a :-> b) -> PA a -> PA b
mapPS (Clo env _ fl) xss =
  fl (replicatePA (lengthPA xss) env) xss

mapPL :: PA (A :-> b) -> PA (PA a) -> PA (PA b)
mapPL (AClo env _ fl) xss =
  unconcatPA xss (fl (expandPA xss env) (concatPA xss))



                      REWRITE RULES


"unitEnv" forall body xs.
            (\(ATup0 n) xs' -> body )
              (replPA (lengthPA xs) ())
              xs
            = (\n xs' -> body ) (lengthPA xs) xs





"unitEnv" proof
f :: PA () -> PA a -> PA a
f (replPA (lengthPA xs) ()) xs
  -- definition of lifted
  = (\(ATup0 n) xs -> body )
    (replPA (lengthPA xs) ())
    xs
  -- no need of Unit Environment-Variables
  = (\n xs -> body ) (lengthPA xs) xs




















